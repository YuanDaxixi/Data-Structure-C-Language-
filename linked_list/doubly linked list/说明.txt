    此为双向链表的一个简单接口，实现了一些常见的基本操作。从单链表处修改而来，两者轮廓所差无几，定义的函数接口除了参数以及返回值的类型外，没有区别。
    单链表只在头部有一个“哨兵”节点，一开始洒家并未考虑那么多，默认双向链表的和单链表一样，一个“哨兵”就行。不过在随后的实现过程发现了一系列问题。原因在于双向链表存在一个prev指针。如果操作最后一个节点（比如删除），那么就得对NULL的prev操作，显然这是不合法的。当然，可以通过添加if判断来解决这个BUG。但是那样使得代码臃肿，因此，洒家选择在链表尾增加另一个“哨兵”来解决这个问题，让tail永远指向这个“哨兵”。这个变化使得几乎所有的循环结束条件由“!=NULL”变为“!=tail”。
    由于双向链表可以轻松获得前一个节点的地址，因此删除了get_prev_node这个函数。增加了一个基于插入排序的排序函数。

定义的函数(操作)有：
1.初始化链表(此时创建“哨兵”)
2.在链表尾部新增一个节点
3.在链表头部新增一个节点（注意是放在哨兵后）
4.将一个节点插到另一个节点之后
5.删除一个节点
6.删除链表（“哨兵”也得死）
7.根据数据查找节点
8.为节点存入数据
9.反转链表（“哨兵”依然是头节点）
10.打印链表（打印的是数据）
11.合并两个链表
12.排序（升序）

具体接口说明见 doubly_linked_list.h 文件
具体定义见 doubly_linked_list.c 文件
函数测试见 test_list_unit.c文件
完整测试见 test_list.c 文件


接着说说 test_list.c的相关问题
    这是第一次写一个比较完整的测试小程序。以模拟“用户”使用的方式来交互。对每个待测试的函数进行了封装...这个封装这是令人心碎啊，由于错误处理和提示的需要，嗯...代码变得很长。里面没有写注释，为什么不写呢？ 谁写谁傻逼！本次令人欣慰的是，写好的代码没有疑难BUG，即使是那出现的孤苦伶仃的BUG，很快就改掉了。因此这块没用啥时间。令人狂躁的是交互界面的问题，为了达到一定的友好程度，改了又改。总之，这次的双向链表的实现气氛上说还是比较健壮的，也是目前令我最欣慰的代码。

一次修改：
    为了使得链表变得通用，洒家将数据的类型改为了void *而非之前的一个结构体。这样凡是和数据有关的函数，其接口有了些许变化，主要改动是其要接受一个函数指针来处理数据，具体函数由具体程序给出实现。这样省去复制代码，修改结构体定义以及修改函数这些讨厌的麻烦。