    此为通用栈的简单接口，与之前链表相同，添加哨兵节点以简化代码。本次实现栈的目的是给以后用到栈的程序提供通用的，简单的接口。核心是push和pop两个操作，并没有实现太多东西。如有需要，以后在具体的程序中添加。
    说一下编写该接口那心酸的历程。从中午回到宿舍不到1点开始，硬是折腾6个小时多。。。只为一个问题：数据的通用！在之前链表的成功经验下，实现了一种数据通用的方式。即通过数据的指针和数据字节的多少来操作。但是...但是...push和pop需要3个参数，这种事情无法让人忍受。本着和正常人一样的思维和习惯：push顶多2个参数――栈和压入的数据。pop一个参数――栈。经过一阵胡思乱想后，最终用宏解决了这一问题。
    用宏和用之前的方式(指针方式)还是有很大区别的，第一个大区别就是宏实现在通用性方面不如指针方式。比如在同一个.c文件中有2个数据对象需要使用栈，并且这2个数据对象所存储的类型不一样。那就必须将这2者分开，不能在同一文件中定义。因为需要对宏传入类型这个参数，生成push和pop的定义。而C语言不支持同名不同参的函数，因此一个文件只能定义一个push和pop。好吧，我刚说一个文件只能定义一个push和pop，刹那间灵感超然，脑门中闪过一个机智的解决办法，我迅速切换到VS2013解除了这个限制。那么现在，这个区别不复存在了。洒家是如何办到的呢？很简单，既然宏接受类型作为参数，那就可以将参数作为函数名字的一部分进行定义！这让我想到了C++和JAVA中重载，哼哼哼，不知道原理是否相同呐！经过这一巧妙地改动，相同类型的数据对象可以使用同一套push和pop。不同类型数据对象也可以定义在同一文件中，只是需要多次通过宏定义push和pop。
    既然这样，宏方式和指针方式的最大区别就变成了代码量的差异。显然，宏方式产生得代码多。因为它要对不同的数据对象定义不同的push和pop。而指针方式不用，大家用的定义只有一个。选择宏方式的另一个重要原因是我觉得指针方式不安全，它需要传入数据对象所占字节数，万一我传入的不是该数据对象的字节数呢？内存越界访问的问题就浮现了。当然这里所谓的宏方式不是函数宏那样子，而是通过宏来定义函数，因此我说的宏方式依然是函数。既然是函数，它就不存在函数宏存在的问题。编译器依然会有类型检查等措施保证正确性。
    当然，宏方式还是具有一定的危险。即push和pop要配套使用。对数据对象A，用push_A和pop_A就不会有问题。但是把push_A和pop_B搭配使用就是错误的。依然有越界访问的危险。解决这一文件的办法就是让push_A只对A可见，B的push只对B可见。而C不是面向对象的，没有对象这样方便的机制来封装。我所能做的就是在函数宏定义前加上static，然后在不同文件中定义A,B。这似乎又回到了最古老的方式。我做了这么多不就是为了能在一个文件定义多个push和pop嘛！因此我没有加static。
    一下午思考这个问题时，很蛋疼。总是出现坐那想了1个小时却毫无进展的情况，真是个忧伤的故事啊。

具体接口说明见stack.h
实现见stack.c
一个简单的测试test_stack.c
a